<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Queenie Lau, Lisa Cheung</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In our second project, Mesh Edit, we utilized Casteljau's algorithm to create Bezier curves and surfaces for geometric objects, implemented the area-weighted vertex normals at vertices for smooth shading, performed edge flip and edge split to manipulate mesh elements, and performed loop subdivision to simulate a high-resolution display in 3D. 
	Our final product allows for us to render high-resolution triangle meshes onto a geometric object along with performing smooth, object shading. 
	Overall, we found it interesting how realistic the geometric object becomes with smooth shading and loop subdivision and how flipping and splitting edges enabled for softer surfaces.
</p>
<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>
  <p>De  Casteljau's algorithm is a recursive algorithm that allows for us to construct 
	  bezier curves from repeated linear interpolation. 
	  We implemented De Casteljau's algorithm by first instantiating a Vector2D for our 
	  intermediate control points. Then, for each original control point in the list of vectors, 
	  we saved that vector point and the next vector point in the list. 
	  We also checked our vector index to ensure that we did not reach the end of the list. 
	  Then, we performed linear interpolation on these two vectors and added the result to our intermediate control points.
  </p>

  <p>
     Screenshots of each step / level of the evaluation from the six original control points down to the final evaluated point shown below.
  </p>

<div align="middle">
  <table style="width=100%">
    <tr>
	  <td>
		<img src="images/tsk1-0.png" align="middle" width="400px"/>
		<figcaption align="middle">Step 0.</figcaption>
	  </td>
      <td>
        <img src="images/tsk1-1.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 1.</figcaption>
      </td>
    </tr>
	<tr>
	<td>
		<img src="images/tsk1-2.png" align="middle" width="400px"/>
		<figcaption align="middle">Step 2.</figcaption>
		</td>
		<td>
			<img src="images/tsk1-3.png" align="middle" width="400px"/>
			<figcaption align="middle">Step 3.</figcaption>
		  </td>
	</tr>
    <br>

    <tr>
      <td>
        <img src="images/tsk1-4.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 4.</figcaption>
      </td>
      <td>
        <img src="images/tsk1-5.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 5.</figcaption>
      </td>
    </tr>

	<br>

    <tr>
      <td>
        <img src="images/tsk1-5.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 5.</figcaption>
      </td>
      <td>
        <img src="images/tsk1-6.png" align="middle" width="400px"/>
        <figcaption align="middle">Final Evaluated Point and Final Bezier Curve.</figcaption>
      </td>
    </tr>

  </table>
</div>

<p>
	Screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter 't' shown below.
</p>

<div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/tsk1-7.png" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
        <td>
          <img src="images/tsk1-8.png" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
      </tr>
      <br>
      <tr>
        <td>
          <img src="images/tsk1-9.png"" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
		<td>
			<img src="images/tsk1-10.png"" align="middle" width="400px"/>
			<figcaption align="middle"></figcaption>
		  </td>
      </tr>
    </table>
  </div>

<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>

  <p>In order to utilize the de Casteljau algorithm to extend to Bezier surfaces, 
	  we first created a temporary array of Vector3D elements and initialized it to have 
	  the same size as controlPoints.size(). 
	  Then, we looped through each control point and fully evaluated de Casteljau's algorithm 
	  at that point with scalar parameter u.
	  Now, we stored the fully evaluated point back into our temporary array of Vector3D elements. 
	  Finally, we evaluated the set of our temporary Vector3D points at scalar parameter v to evaluate Bezier surfaces along the y-axis. 
  </p>

  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/tsk2-1.png" align="center" width="600px"/>
          <figcaption align="middle">Evaluated bezier teapot surface</figcaption>
		</td>
      </tr>
    </table>
  </div>

<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>
<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>
  <p>To implement area-weighted vertex normals, we first started at the half-edge that was associated with the given vertex. 
	  From that half-edge, we called next() to get the rest of the vertex positions associated with that triangle face. 
	  Using the vertex positions of the triangle, we found the normal using the cross product[how], and also the area [how]of the triangle to get the weighted normal,and added it to the Vector3D result. 
	  Geometrically, the normal for a triangle face is the vector perpendicular to a surface at a given point. In order to get the weighted normals for all the triangle faces associated with the given vertex, we used iteration and called on the half-edges twin which had the given vertex associated with it. We normalized the final Vector3D result to get the resulting area-weighted normal vector.
  </p>

<h3 align="middle">Part 4: Edge Flip</h3>
  <p>
    To implement edge flip operation, we first drew and labeled the edge flip diagram with two triangles to illustrate how the triangles would look before the edge flip operation. 
	Then, we drew the diagram of how the two triangles would look after the edge flip. 
	To implement flipEdge, we first updated the pointers of each halfedge to match the finished edge flip diagram. 
	Similarly, we then updated the pointers for each edge, vertex, and face. 
	Next, we set the neighbors of each half edge to by indicating the half edge's next, twin, vertex, edge, and face. 
	Finally, we returned the EdgeIterator, e0.
  </p>
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/tsk4-1.png" align="middle" width="400px"/>
          <figcaption align="middle">Before Edge Flip</figcaption>
        </td>
        <td>
          <img src="images/tsk4-2.png" align="middle" width="400px"/>
          <figcaption align="middle">After One Edge Flip</figcaption>
        </td>
		<tr>	
		</tr>
    </table>
	<img src="images/tsk4-3.png" align="middle" width="800px"/>
	<figcaption align="middle">Multiple Edge Flips</figcaption>
  </div>


<h3 align="middle">Part 5: Edge Split</h3>
  <p>To implement the edge split operation, we first enumerated the old mesh's half edge elements. 
	  Then, we created new half edges, edges, and faces to account for after the edge split. 
	  We then listed out the  re-used edges and vertices to create a new vertex iterator. 
	  After, we set the position of our new vertex and updated the pointers for our two faces, updated our vertex half edges, updated our face half edges, and updated our edge half edges. 
	  Lastly, we set the neighbors of each halfedge and returned the newly created vertex iterator.
  </p>

  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/tsk5-1.png" align="middle" width="400px"/>
          <figcaption align="middle">Cow mesh before edge splits.</figcaption>
        </td>
        <td>
          <img src="images/tsk5-2.png" align="middle" width="400px"/>
          <figcaption align="middle">Cow mesh with edge splits.</figcaption>
        </td>
      </tr>

      <tr>
        <td>
          <img src="images/tsk5-3.png" align="middle" width="400px"/>
          <figcaption align="middle">Cube before edge splits and edge flips.</figcaption>
        </td>
        <td>
          <img src="images/tsk5-4.png" align="middle" width="400px"/>
          <figcaption align="middle">Cube with edge splits and edge flips.</figcaption>
        </td>
      </tr>
    </table>
  </div>

<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
  <p>
    To implement loop division, we first iterated through each original point in the mesh and marked each original vertex as old. 
    Then, for each old vertex, we evaluated their new positions and stored them inside the newPosition vertex. 
    In order to evaluate the new positions, we got the neighbors of each vertex, their degree, and their respective weight according to the rule 3/(8 * degree of vertex) except when the degree is three, then  the weight would equal 3/16. 
    Next, we iterated through each edge in the mesh, got the edge's neighboring faces, and the neighboring faces' half-edges to evaluate their vertex positions. 
    We then utilized these two vertex positions to get two more vertex positions (mirrored to the previous two), weighted them accordingly, and evaluated the updated vertex positions. 
    Next, we split every edge in the mesh that is not an original edge and flipped the new edges that connect an old and new vertex.
    Finally, we iterated through each vertex to copy their new vertex positions into the final position vertex.
  </p>

  <p>
    After loop division, we can see how the cube becomes significantly smoother since we start to lose the sharp corners and edges. 
    By pre-splitting some edges, we don't see this smoothing effect as much because  we are averaging from a larger set of vertices. 
    Thus, there's a lot more edges and faces that we would need to subdivide to smoothen out our cube.
    After several iterations, we see that the cube does become slightly asymmetric after the subdivisions.  
    The asymmetric cube shape comes from how we are weighing our old vertices and new vertices. 
    The uneven weighing is what leads to the  asymmetric cube.  
    So, this is where the pre-splitting and pre-flipping comes into hand.  
  </p>
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/tsk6-1.png" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
        <td>
          <img src="images/tsk6-2.png" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
      </tr>
      <br>
      <tr>
        <td>
          <img src="images/tsk6-3.png" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
        <td>
          <img src="images/tsk6-4.png" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/tsk6-5.png" align="middle" width="400px"/>
          <figcaption align="middle"></figcaption>
        </td>
      </tr>
    </table>
  </div>

<p>Link: <a href="https://cal-cs184-student.github.io/sp22-project-webpages-Queenie-Lau/proj2/index.html">Project 2</a></p>
</body>
</html>